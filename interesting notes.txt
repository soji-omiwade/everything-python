Each module has its own private symbol table, which is used as the global symbol table by all functions defined in the module. Thus, the author of a module can use global variables in the module without worrying about accidental clashes with a user’s global variables. 
_____On the other hand, if you know what you are doing you can touch a module’s global variables with the same notation used to refer to its functions, modname.itemname._____

interesting note: above underlined: it implies normally when you import a module, you 
usually just call its functions, not access its global variables. Wow



another interesting point: 
Note For efficiency reasons, each module is only imported once per interpreter session. Therefore, if you change your modules, you must restart the interpreter – or, if it’s just one module you want to test interactively, use importlib.reload(), e.g. import importlib; importlib.reload(modulename).
----it's because of efficiency that modules are imported only once! i thought
it had to do with not changing the globals in the module being imported
once they've been set. 


wow. interesting stuff
import statement is what generates the compiled pyc files. or you run python 
followed by the module (in which case it always runs). for just regular import
it won't do it, if it is done in just a regular import or .. there's no source
module. in which case u gotta put the pyc file in the source folder.



yet another one: 
A program doesn’t run any faster when it is read from a .pyc file than when it is read from a .py file; the only thing that’s faster about .pyc files is the speed with which they are loaded.


thanks to stack overflow: the difference between an interpreter and a virtual 
machine: https://stackoverflow.com/a/2998228/850423
They contain byte code, which is what the Python interpreter compiles the source to. This code is then executed by Python's virtual machine.


how does the interpreter find module spam when it sees a "import spam"?
1) it looks in the built-ins. then,
2) it looks in sys.path (which as i understand, will start with the current dir, 
    even if the current dir isn't explicitly there -- something about sym links)

the above is sorta the reverse of when you have a name and the interpreter
must determine the appropriate namespace. it starts local, then enclosing func, 
then global variables, then built-ins. hmm... maybe not really. above has to do 
with which path has the module file (the py file), while this is more of which 
scope/namespace has the variable we're looking for!

import blah be it import blah or from boo import blah. only brings in the blah
nothing in boo will be brought in, even boo itself isn't brought in.

