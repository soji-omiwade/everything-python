Each module has its own private symbol table, which is used as the global symbol table by all functions defined in the module. Thus, the author of a module can use global variables in the module without worrying about accidental clashes with a user’s global variables. 
_____On the other hand, if you know what you are doing you can touch a module’s global variables with the same notation used to refer to its functions, modname.itemname._____

interesting note: above underlined: it implies normally when you import a module, you 
usually just call its functions, not access its global variables. Wow



another interesting point: 
Note For efficiency reasons, each module is only imported once per interpreter session. Therefore, if you change your modules, you must restart the interpreter – or, if it’s just one module you want to test interactively, use importlib.reload(), e.g. import importlib; importlib.reload(modulename).
----it's because of efficiency that modules are imported only once! i thought
it had to do with not changing the globals in the module being imported
once they've been set. 


wow. interesting stuff
import statement is what generates the compiled pyc files. or you run python 
followed by the module (in which case it always runs). for just regular import
it won't do it, if it is done in just a regular import or .. there's no source
module. in which case u gotta put the pyc file in the source folder.



yet another one: 
A program doesn’t run any faster when it is read from a .pyc file than when it is read from a .py file; the only thing that’s faster about .pyc files is the speed with which they are loaded.


thanks to stack overflow: the difference between an interpreter and a virtual 
machine: https://stackoverflow.com/a/2998228/850423
They contain byte code, which is what the Python interpreter compiles the source to. This code is then executed by Python's virtual machine.


how does the interpreter find module spam when it sees a "import spam"?
1) it looks in the built-ins. then,
2) it looks in sys.path (which as i understand, will start with the current dir, 
    even if the current dir isn't explicitly there -- something about sym links)

the above is sorta the reverse of when you have a name and the interpreter
must determine the appropriate namespace. it starts local, then enclosing func, 
then global variables, then built-ins. hmm... maybe not really. above has to do 
with which path has the module file (the py file), while this is more of which 
scope/namespace has the variable we're looking for!

import blah be it import blah or from boo import blah. only brings in the blah
nothing in boo will be brought in, even boo itself isn't brought in.

it takes a little bit for this to sink in. but it will make sense once u think 
about it: 
https://docs.python.org/3/tutorial/modules.html#intra-package-references

Note that relative imports are based on the name of the current module. Since the name of the main module is always "__main__", modules intended for use as the main module of a Python application must always use absolute imports.

finally figured out what the eval does: you've got an expr say you want to 
evaluate later. use the repr! it encapsulates the expr as a string. such that
when you run eval(repr(expr)), you get back your expression. so: 
eval: takes a string and evaluates the content
repr: makes it possible to stringify an expr so that if you need to get it back
you can run eval() on the string returned by repr. or....
UPDATE: official python https://docs.python.org/3/library/functions.html#ascii
states that repr returns a printable representation of an object

alas. i get the meaning of the bare asterisk: if you are going to specify
an argument after the *, then it must be a keyword arg so to so, up until the
**kw
next thing to quickly do: what's the meaning of '/' when passed as a parameter

not only does the author of the tutorial avoid long lines, but they don't use \
to break lines. they just use two prints instead!
>>> for x in range(1, 11):
...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')
...     # Note use of 'end' on previous line
...     print(repr(x*x*x).rjust(4))


it's interesting at first to find that (i) scalar to vector multiplication and (ii) vector addition is not built into python. but then you realize that this is because the implementation you expect already has a meaning: append! That is, already we have 
i) [2,3] + [14,5] = [2,3,14,5] and 
ii) 3 * [4,5] = [4, 5, 4, 5, 4, 5]
